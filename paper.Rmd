---
title: "Percolation analysis of transect data"
author:
  -Schmidt, Sophie C.
  - Author Two
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
    bookdown::word_document2:
      fig_caption: yes
      reference_docx: "../templates/template.docx" # Insert path for the DOCX file

abstract: |
  Text of abstract
keywords: |
  keyword 1; keyword 2; keyword 3
highlights: |
  These are the highlights. 
---



```{r, setup, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  comment = "#>",
  fig.path = "../figures/"
)


#library(percolatransect) # Or use devtools::load_all('.', quiet = T) if your code is in script files, rather than as functions in the `/R` diretory
```

## 


## different cluster analysis visualisation

Einladen der Daten und verbindung:
```{r}
#Data cleaning and prep for Sophie

# load data
BefSchnitt <- read.csv2('source_data/Schnittbefunde4.csv', sep = "\t", dec = ",")

# bringing the periods in the right order
BefSchnitt$epoche <- ordered(BefSchnitt$epoche, levels = c("Neolithikum", "Bronzezeit", "Eisenzeit", "undat."))
BefSchnitt$abschnitt <- ordered(BefSchnitt$abschnitt, levels =c('aelter', 'frueh','mittel', 'spaet'))
BefSchnitt$kultur <- ordered(BefSchnitt$kultur, levels=c("Baalberge", "Bernburg", "Kugelamphorenkultur", "Trichterbecher", "Salzmuende", "Schnurkeramik", "Glockenbecher", "Aunjetitz", "Saalemuendungsgruppe", "sBZ/aeEZ", "Hausurnenkultur"))

# subset settlement features
siedlung_BefSchnitt <- subset(BefSchnitt, BefSchnitt$befundart=='Siedlung')

#Subset the settlement features for relevant cultures
# there are 389 features dated as late bronze age and early iron age, that are being analysed in both epochs
siedlung_SnK_Bef <- subset(siedlung_BefSchnitt, siedlung_BefSchnitt$kultur=='Schnurkeramik')
siedlung_SnK_Bef <-siedlung_SnK_Bef[c('PlcIndex', 'Easting', 'Northing')]
write.csv(siedlung_SnK_Bef, "source_data/BefundesNL-minimal.csv", row.names = FALSE)

siedlung_fBZ_Bef <- subset(siedlung_BefSchnitt,
                           siedlung_BefSchnitt$epoche=='Bronzezeit' &
                             siedlung_BefSchnitt$abschnitt=='frueh')
siedlung_fBZ_Bef <- siedlung_fBZ_Bef[c('PlcIndex', 'Easting', 'Northing')]
write.csv(siedlung_fBZ_Bef, "source_data/BefundefBZ-minimal.csv", row.names = FALSE)

siedlung_sBZ_Bef <-subset(siedlung_BefSchnitt, siedlung_BefSchnitt$epoche=='Bronzezeit' & siedlung_BefSchnitt$abschnitt=='spaet')
siedlung_sBZ_Bef <-siedlung_sBZ_Bef[c('PlcIndex', 'Easting', 'Northing')]
write.csv(siedlung_sBZ_Bef, "source_data/BefundesBZ-minimal.csv")


siedlung_sBZ_aeEZ_Bef <- subset(siedlung_BefSchnitt, siedlung_BefSchnitt$epoche=='Eisenzeit' & siedlung_BefSchnitt$abschnitt=='aelter')
siedlung_sBZ_Bef <-siedlung_sBZ_aeEZ_Bef[c('PlcIndex', 'Easting', 'Northing')]
write.csv(siedlung_sBZ_Bef, "source_data/BefundesBZ_aeEZ-minimal.csv")

```


## run analysis and save results of every run.

### input in source _file.txt
source_file,map_name,shape_file_name,DTM_file_name
BefundesNL-minimal.csv, late neolithic features, alle_Schnitt-Fundstellen.shp,

source_file,map_name,shape_file_name,DTM_file_name
BefundefBZ-minimal.csv, early bronze age features, alle_Schnitt-Fundstellen.shp,

source_file,map_name,shape_file_name,DTM_file_name
BefundesBZ-minimal.csv, late bronze age features, alle_Schnitt-Fundstellen.shp,

source_file,map_name,shape_file_name,DTM_file_name
BefundesBZ_aeEZ-minimal.csv, late bronze age to early iron age features, alle_Schnitt-Fundstellen.shp,

### input in radius_values.txt (stays)

upper_radius,lower_radius,step_value,limit,upper_threshold,lower_threshold,radius_unit
500,2,1, 1000,0,0,1

Außer bei der fBZ: da muss der minimale Radius 4 sein.
## run code (each time new after changing source_file.txt and saving results somewhere)

```{r}
source("create_nodes_list_d.v4.7.R")
source("clustering_script.v3.6.R")
#source("mapping_clusters.v4.12.R")# Fehler in ogrInfo(dsn = dsn, layer = layer, encoding = encoding, use_iconv = use_iconv, : Cannot open data source... weeiiiiird... nochmal auf anderer Maschine testen.

source("cluster_frequency_script.v2.16.R")

```

Jeweils die Daten in die vorgesehenen Ordnern verschieben.

## für vergleichende plots:

```{r combine all tables}
library(utils)

sNL1 <- read.csv("analysis_results/sNL/1m_sNL/analysis_by_radius.csv")
fBZ1  <- read.csv("analysis_results/fBZ/analysis_by_radius.csv")
sBZ1  <- read.csv("analysis_results/sBZ/sBZ_1m/analysis_by_radius.csv")
aeEZ1  <- read.csv("analysis_results/aeEZ/analysis_by_radius.csv")

sNL1$period  <- "Spätneolihitikum"
fBZ1$period  <- "Frühbronzezeit"
sBZ1$period  <-  "Spätbronzezeit"
aeEZ1$period <- "ältere Eisenzeit"

radius1 <- rbind(sNL1,sBZ1, fBZ1, aeEZ1)

```



## try new things

```{r mean cluster size}
library(ggplot2)

ggplot( data = radius1)+
  geom_line(aes(x = radius, y = mean_clust_size, col = period))
```

```{r anzahl cluster}
library(ggplot2)
ggplot( data = radius1)+
  geom_line(aes(x = radius, y = max_normalized, col = period))+
  theme_light()+
  labs(x ="percolation radius", y = "normalized maximum cluster size",
       title = "Comparison of different time periods")

ggsave("normalized_max_clusters.png", height = 10, width =  20, units = "cm", dpi = 300  )

```
# auslesen der "knackpunkte"?

```{r }
## not happy with results here. esp. for EZ.
# google terms: knee of curve, "trade off point"
#https://dataplatform.cloud.ibm.com/analytics/notebooks/54d79c2a-f155-40ec-93ec-ed05b58afa39/view?access_token=6d8ec910cf2a1b3901c721fcb94638563cd646fe14400fecbb76cea6aaae2fb1

#https://www.rdocumentation.org/packages/SamSPECTRAL/versions/1.26.0/topics/kneepointDetection


points <-  c(1,1+which(diff(sNL1$max_normalized)!=0))

sNL1points<- as.data.frame(cbind(sNL1$radius[points], sNL1$max_normalized[points]))

pointssBZ <-  c(1,1+which(diff(sBZ1$max_normalized)!=0))

sBZ1points<- as.data.frame(cbind(sBZ1$radius[pointssBZ], sBZ1$max_normalized[pointssBZ]))


pointssBZ <-  c(1,1+which(diff(sBZ1$max_normalized)!=0))

sBZ1points<- as.data.frame(cbind(sBZ1$radius[pointssBZ], sBZ1$max_normalized[pointssBZ]))

pointsaeEZ <-c(1,1+which(diff(aeEZ1$max_normalized)!=0))
aeEZpoints <-as.data.frame(cbind(aeEZ1$radius[pointsaeEZ],
aeEZ1$max_normalized[pointsaeEZ]))


ggplot()+
  geom_line(data = radius1, aes(x = radius, y = max_normalized, col = period))+
  geom_point(data = sNL1points, aes(x = sNL1points$V1,  y =sNL1points$V2), alpha = 0.5)+
  geom_point(data = sBZ1points, aes(x=sBZ1points$V1, y=sBZ1points$V2), alpha = 0.5)+
  geom_point(data = aeEZpoints, aes(x=aeEZpoints$V1, y=aeEZpoints$V2))

```
Die Points sind bereits wichtige Radii-Angaben, weil der URsprungsdatensatz ja auch einfach bei 1 = 1m anfängt.

Welcher Knickpunkt ist wichtig? Wendepunkte berechnen:

```{r}

# calculate turning points of distance measure vectors


#install.packages("ecp")
library("ecp")

turn_sNL <- e.divisive(as.matrix(diff(sNL1$max_normalized)), k = 1, min.size = nrow(sNL1)/10) #looks for change points, needs matrix, k number of changepoints estimated, min.size = minimum number of observations between change points -> decided to be a tenth of the number of observations so it's not every small change that's documented

sNL_turn_r <-sNL1$radius[turn_sNL$estimates]


# same late bronze age
turn_sBZ <- e.divisive(as.matrix(diff(sBZ1$max_normalized)), k = 1, min.size = nrow(sBZ1)/10) 

sBZ_turn_r <-sBZ1$radius[turn_sBZ$estimates]

# same early iron age
aeEZ_turn  <- e.divisive(as.matrix(diff(aeEZ1$max_normalized)), k = 1, min.size = nrow(aeEZ1)/10)

aeEZ_turn_r <- aeEZ1$radius[aeEZ_turn$estimates]

```

##Tabelle anschauen

```{r}
sNL_turn_r[2]
sBZ_turn_r[2]
aeEZ_turn_r[2]
```



# next point: Vergleich mit meinen density daten?


# Idee: Daten einladen, teilen, etc, run source, 

copied from old:
```{r eval=FALSE, message=FALSE, cache=FALSE, include=FALSE}

#load data
BefSchnitt <- read.csv2('../data/Schnittbefunde4.csv')

# order dating
BefSchnitt$epoche <- ordered(BefSchnitt$epoche, levels = c("Neolithikum", "Bronzezeit", "Eisenzeit", "undat."))
BefSchnitt$abschnitt <- ordered(BefSchnitt$abschnitt, levels =c('aelter', 'frueh','mittel', 'spaet'))
BefSchnitt$kultur <- ordered(BefSchnitt$kultur, levels=c("Baalberge", "Bernburg", "Kugelamphorenkultur", "Trichterbecher", "Salzmuende", "Schnurkeramik", "Glockenbecher", "Aunjetitz", "Saalemuendungsgruppe", "sBZ/aeEZ", "Hausurnenkultur"))

library(maptools)
library(spatstat)
library(rgdal)
library(ggplot2)
library(pastecs)

# subset settlement features

siedlung_BefSchnitt <- subset(BefSchnitt, BefSchnitt$befundart=='Siedlung')

#Subset for cultures
siedlung_SnK_Bef <-subset(siedlung_BefSchnitt, siedlung_BefSchnitt$kultur=='Schnurkeramik')
siedlung_fBZ_Bef <-subset(siedlung_BefSchnitt, siedlung_BefSchnitt$epoche=='Bronzezeit' & siedlung_BefSchnitt$abschnitt=='frueh')
siedlung_sBZ_Bef <-subset(siedlung_BefSchnitt, siedlung_BefSchnitt$epoche=='Bronzezeit' & siedlung_BefSchnitt$abschnitt=='spaet')
siedlung_aeEZ_Bef <- subset(siedlung_BefSchnitt, siedlung_BefSchnitt$epoche=='Eisenzeit' & siedlung_BefSchnitt$abschnitt=='aelter')
siedlung_sBZaeEZ_Bef <-subset(siedlung_BefSchnitt, siedlung_BefSchnitt$kultur=='sBZ/aeEZ')

siedlung_sBZ_aeEZ <- rbind(siedlung_sBZaeEZ_Bef, siedlung_aeEZ_Bef)

###2. create spatstat-Objects (> ppp(x.coordinates, y.coordinates, x.range, y.range bzw window))

window <- readOGR(dsn='../data', layer='win_Schnitt')
win <- as(window, "SpatialPolygons")
W <-as(win, "owin")

siedlung_SnK_Bef_pp <- ppp(siedlung_SnK_Bef$X, 
 siedlung_SnK_Bef$Y, 
 W)
siedlung_fBZ_Bef_pp <- ppp(siedlung_fBZ_Bef$X, 
 siedlung_fBZ_Bef$Y, 
 W)
siedlung_sBZ_Bef_pp <- ppp(siedlung_sBZ_Bef$X, 
 siedlung_sBZ_Bef$Y, 
 W)
siedlung_aeEZ_Bef_pp <- ppp(siedlung_aeEZ_Bef$X, 
  siedlung_aeEZ_Bef$Y, 
  W)
siedlung_sBZ_aeEZ_pp <-ppp(siedlung_sBZ_aeEZ$X,
 siedlung_sBZ_aeEZ$Y,
 W)

# Warnung: dublicated points in sBZ und aeEZ.
siedlung_sBZ_Bef_pp <- unique(siedlung_sBZ_Bef_pp) # dopplungen raus
siedlung_aeEZ_Bef_pp <- unique(siedlung_aeEZ_Bef_pp) # dopplungen raus
siedlung_sBZ_aeEZ_pp <- unique(siedlung_sBZ_aeEZ_pp) # dopplungen raus


# calculate distance matrix and create vector and dataframe
siedlSnK_dist_v <- sort(as.vector(pairdist.ppp(siedlung_SnK_Bef_pp)))# Entfernung aller SnK-Punkte zueinander
siedlSnK_dist_v <-subset(siedlSnK_dist_v, siedlSnK_dist_v > 0) # 0-Werte raus
siedlSnK_dist_df <- as.data.frame(siedlSnK_dist_v)

siedlfBZ_dist_v <- sort(as.vector(pairdist.ppp(siedlung_fBZ_Bef_pp)))# Entfernung aller fBZ-Punkte zueinander
siedlfBZ_dist_v <-subset(siedlfBZ_dist_v, siedlfBZ_dist_v > 0) # 0-Werte raus
siedlfBZ_dist_df <- as.data.frame(siedlfBZ_dist_v)

siedlsBZ_dist_v <- sort(as.vector(pairdist.ppp(siedlung_sBZ_Bef_pp)))# Entfernung aller sBZ-Punkte zueinander
siedlsBZ_dist_v <-subset(siedlsBZ_dist_v, siedlsBZ_dist_v > 0) # 0-Werte raus
siedlsBZ_dist_df <- as.data.frame(siedlsBZ_dist_v)

siedlaeEZ_dist_v <-sort(as.vector(pairdist.ppp(siedlung_aeEZ_Bef_pp)))# Entfernung aller aeEZ-Punkte zueinander
siedlaeEZ_dist_v <-subset(siedlaeEZ_dist_v, siedlaeEZ_dist_v > 0) # 0-Werte raus
siedlaeEZ_dist_df <- as.data.frame(siedlaeEZ_dist_v)

siedlsBZ_aeEZ_dist_v <- sort(as.vector(pairdist.ppp(siedlung_sBZ_aeEZ_pp )))# Entfernung aller sBZ/aeEZ-Punkte zueinander
siedlsBZ_aeEZ_dist_v <-subset(siedlsBZ_aeEZ_dist_v, siedlsBZ_aeEZ_dist_v > 0) # 0-Werte raus
siedlsBZ_aeEZ_dist_df <- as.data.frame(siedlsBZ_aeEZ_dist_v)

# subset to only 1000m

siedlSnK_dist_df_1000 <-subset(siedlSnK_dist_df, siedlSnK_dist_df > 0 & siedlSnK_dist_df < 1000 )

siedlfBZ_dist_df_1000 <-subset(siedlfBZ_dist_df, siedlfBZ_dist_df > 0 & siedlfBZ_dist_df < 1000 )

siedlsBZ_dist_df_1000 <-subset(siedlsBZ_dist_df, siedlsBZ_dist_df > 0 & siedlsBZ_dist_df < 1000 )

siedlsBZ_aeEZ_dist_df_1000 <-subset(siedlsBZ_aeEZ_dist_df, siedlsBZ_aeEZ_dist_df > 0 & siedlsBZ_aeEZ_dist_df < 1000 )


siedlsBZ_aeEZ_dist_df_1000 <-subset(siedlsBZ_aeEZ_dist_df, siedlsBZ_aeEZ_dist_df > 0 & siedlsBZ_aeEZ_dist_df < 1000 )

# create cumulative sums and percentage of those

siedlSnK_dist_df_1000$n <-c(1:nrow(siedlSnK_dist_df_1000)) # sagt, wie viele so oder kleiner (weil vorher nach Größe sortiert)
siedlSnK_dist_df_1000$prozent <-c(siedlSnK_dist_df_1000$n/nrow(siedlSnK_dist_df_1000)) # macht aus der Anzahl eine Prozentanzahl zur Vergleichbarkeit

siedlfBZ_dist_df_1000$n <-c(1:nrow(siedlfBZ_dist_df_1000))
siedlfBZ_dist_df_1000$prozent <-c(siedlfBZ_dist_df_1000$n/nrow(siedlfBZ_dist_df_1000))

siedlsBZ_dist_df_1000$n <-c(1:nrow(siedlsBZ_dist_df_1000))
siedlsBZ_dist_df_1000$prozent <-c(siedlsBZ_dist_df_1000$n/nrow(siedlsBZ_dist_df_1000))

siedlsBZ_aeEZ_dist_df_1000$n <-c(1:nrow(siedlsBZ_aeEZ_dist_df_1000))
siedlsBZ_aeEZ_dist_df_1000$prozent <-c(siedlsBZ_aeEZ_dist_df_1000$n/nrow(siedlsBZ_aeEZ_dist_df_1000))

siedlsBZ_aeEZ_dist_df_1000$n <-c(1:nrow(siedlsBZ_aeEZ_dist_df_1000))
siedlsBZ_aeEZ_dist_df_1000$prozent <-c(siedlsBZ_aeEZ_dist_df_1000$n/nrow(siedlsBZ_aeEZ_dist_df_1000))


```



new:

```{r anzahl cluster2, eval=FALSE, include=FALSE}
ggplot( data = radius1)+
  geom_line(aes(x = radius, y = max_normalized, col = period))+
  geom_density()
```


# Conclusion

# Acknowledgements

<!-- The following line inserts a page break when the output is MS Word. For page breaks in PDF, use \newpage on its own line.  -->
##### pagebreak

# References 
<!-- The following line ensures the references appear here for the MS Word or HTML output files, rather than right at the end of the document (this will not work for PDF files):  -->
<div id="refs"></div>

##### pagebreak

### Colophon

This report was generated on `r Sys.time()` using the following computational environment and dependencies: 

```{r colophon, cache = FALSE}
# which R packages and versions?
devtools::session_info()
```

