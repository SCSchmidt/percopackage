# CLUSTER FREQENCY PLOTTING SCRIPT
# Simon Maddison, 10th May 2015
# Version 2.1: 2/10/15 - Tidied up, paths and added plot of radius vs # of clusters
# Version 2.2: 31/1/16 -  Labels added to the second plot, requires the textxy function in calibrate package
# Note odd plot of radius 1 if included, due to clustering idiosyncracy that does not include clusters of 1.
# Version 2.3: 30/3/16 - Extended to include plots of average and median cluster sizes on the same plot 
# 	(currently max size). Changed outputs to multi-page pdf files
# Version 2.4: 20/4/16 - Plot to log log added for median. Defined range plot removed
# Version 2.5: 23/4/16 -
#	Added in computations for clusters of single nodes
# 	Totals of nodes and number of clusters take account of single nodes as clusters of 1
#	Table of max, mean and median exported
# Version 2.6: 26/4/16 -
# 	As per Elsa's paper, plot 'S_mean' cluster size, vs radius, 
# 	Exclude clusters with less than a certain threshold of nodes (parameter)
# 	Also exclude largest cluster from mean
# 	Thresholds for upper and lower calculations of S_mean read in from radius_values text file
# Version 2.7: 29/4/16 -
#	As per Elsa's published paper, plot max cluster size vs. radius as well
# 	Page format improved to generate pdf A4 format
# 	Bug fixed when adding clusters of size 1 (if null value)
# Version 2.8: 4/5/16 - 
#	As per Elsa's published paper, max also plotted as normalized relative to total number of nodes
# Version 2.9: 6/5/16 -
#	Problem with S_mean if number of clusters becomes zero, resolved, and also corrected computation
# Version 2.10: 8/5/16 - source text file format changed to include map information
# Version 2.11: 18/5/16 - updated to read cluster data from combined file that is now generated by other programs
#	File is member_cluster_by_radius.csv
# Version 2.12: 30/7/16 - data output as png file, easier to incorporate in word doc
#	Make the image square or else it distorts the plot (note that this does not happen in pdf)
# 	Remove simple cluster rank plots, no longer useful
# Version 2.13: 7/11/17	- amended working directory path for new pc
# Version 2.14: 17/11/17 - amended to allow for multiple file versions based on additional 'k' factor
#	used by dbScan. For each run there may be more than one value of k, so one file generated per value 
# 	value included in the file name. NOTE THIS WILL NEED AMENDING FOR PERCOLATION SCRIPTS TO UPDATE
#	Some plots removed, legacy of earlier attempts at analysis
# Version 2.15: 10/01/18 - if dbscan values are null, then treat as percolation and name files accordingly.
# Version 2.16: 03/12/18 - added in unit parameter to radius_values.txt to allow for different units 

# This script extracts cluster frequency data and plots it for a range of percolation radii
# The data is in the working directory in text files;
# 	each file is a list of Place indices, with the identity of each cluster  
# 	which it is a member of
setwd("D:/Iron_Age_Hillforts/Percolation")
# paths
path_source <- paste(getwd(),"/source_data",sep="")
path_working <- paste(getwd(),"/working_data",sep="")
path_results <- paste(getwd(),"/analysis_results",sep="")
library(calibrate)

# Read in source file name defined in file source_file.txt
file_name <- paste(path_working,"/","source_file.txt",sep="")
source_files <- read.csv(file_name,header=TRUE,stringsAsFactors=FALSE)
source_file_name <- source_files$source_file
file_name <- paste(path_source,"/",source_file_name,sep="")

# Read source file to establish number of nodes (entries in the file)
# subtract 1 for header line
total_nodes <- length(readLines(file_name)) -1

# Read in distance thresholds - this ensures same values used in all scripts
# Edit the source file radius_values.txt to change these.
file_name <- paste(path_working,"/","radius_values.txt",sep="")
radius_values <- read.csv(file_name,header=TRUE)
upper_radius <- radius_values$upper_radius
lower_radius <- radius_values$lower_radius
step_value <- radius_values$step_value
unit <- radius_values$unit
if (unit == 1)
{unit_text <- "m")
if (unit_text == 

upper_threshold <- radius_values$upper_threshold
lower_threshold <- radius_values$lower_threshold
upper_cluster_minimum <- radius_values$upper_cluster_minimum
lower_cluster_minimum <- radius_values$lower_cluster_minimum

# If one or both of these are Null, then set minimum to 1
# assume percolation and not dbscan
if(is.null(upper_cluster_minimum)|is.null(lower_cluster_minimum))
{	
	percolation <- TRUE
	upper_cluster_minimum <- 1
	lower_cluster_minimum <- 1
	print("Minimum cluster size set to 1, as one or both values read are Null; assume percolation and not dbscan")
}
radius_values <- seq(lower_radius,upper_radius,by=step_value)
cluster_min_values <- seq(upper_cluster_minimum,lower_cluster_minimum,by=-1)



for(cluster_min in cluster_min_values)
	{
	# Reads in file of data giving cluster ids indexed by radius, for each node
	if(percolation== TRUE)
	{
		file_name <- paste(path_working,"/","member_cluster_by_radius.csv",sep="")
	} else {
		file_name <- paste(path_working,"/","member_cluster_by_radius_k",cluster_min,".csv",sep="") 
	}
	mem_clust_by_r <- read.csv(file_name, header = TRUE)

	# Create matrix of number of clusters and number of nodes (max, mean, median, S_mean), for each radius
	# Columns:  Radius, number of clusters, max cluster size, mean cluster size, median cluster size, S mean 
	col_list <- cbind('radius','num_clust','max_clust_size','max_normalized','mean_clust_size','median_clust_size','S_mean')
	
	#n_rows <- upper_radius - lower_radius +1
	n_rows <- length(radius_values)
	analysis_by_radius <- matrix(, nrow = n_rows, ncol = 7)
	colnames(analysis_by_radius) <- col_list
	row <- 1

	for(i in radius_values)
	{
		print(paste("i ",i))
		# Reads in data for each percolation radius that has been computed, and if appropriate by minimum cluster size
		# This lists each node and the id of the cluster to which it is a member, for this radius
		ClstRad_col <- paste("ClstRad",i,sep="")
		member_cluster <- mem_clust_by_r[c("PlcIndex", ClstRad_col)]
		names(member_cluster) <- c('node','cluster')
		member_cluster <- na.omit(member_cluster)

		# number of nodes in clusters, i.e. excluding single nodes
		total_clustered_nodes <- nrow(member_cluster)
		# Ranks clusters by size, i.e. number of nodes for each cluster
		frequency_clusters <- data.frame(table(member_cluster$cluster))
		names(frequency_clusters) <- c('cluster','number_of_nodes')
		ranked_clusters <- frequency_clusters[order(frequency_clusters$number_of_nodes, decreasing=TRUE),]
		# Convert cluster column from factor to numeric, else problems later
		ranked_clusters$cluster <- as.numeric(as.character(ranked_clusters$cluster))
		number_of_clusters <- nrow(ranked_clusters)

		# add in clusters of size 1; compute number of these clusters
		add_row_total <- total_nodes - total_clustered_nodes
		if(add_row_total>0)
		{
			supp_array <- data.frame(seq((number_of_clusters+1),(number_of_clusters + add_row_total)))
			one_col <- data.frame(rep(1,times=add_row_total))
			supp_array <- cbind(supp_array,one_col)
			names(supp_array) <- c('cluster','number_of_nodes')
			# ranked_clusters now includes clusters of size 1
			# makes consistent measure of means medians for different percolation radii
			ranked_clusters <- rbind(ranked_clusters,supp_array)
		}
		# revised number of clusters
		number_of_clusters <- nrow(ranked_clusters)
		# The number of nodes in the first ranked cluster is maximum
		max_nodes <- ranked_clusters$number_of_nodes[1]
		max_normalized <- max_nodes/total_nodes
		mean_nodes <- mean(ranked_clusters$number_of_nodes)
		median_nodes <- median(ranked_clusters$number_of_nodes)

		# 'S mean' for clusters, excluding largest, and also excluding clusters of smaller size 
		# These upper and lower thresholds defined in input radius_values text file
		# lower_threshold - read in from text file. Clusters with this number of nodes or less excluded
		# upper_threshold - read in from text file. Number of largest clusters to be excluded
		constrained_ranked_clusters <- ranked_clusters[ranked_clusters$number_of_nodes > lower_threshold,]
		constrained_number_of_clusters <- nrow(constrained_ranked_clusters)
		if((upper_threshold+1) <= constrained_number_of_clusters)
		{	
			S_mean <- mean(constrained_ranked_clusters$number_of_nodes[(upper_threshold+1):constrained_number_of_clusters])
		} else {
			S_mean <- 0
		}

		analysis_by_radius[row,] <- cbind(i,number_of_clusters,max_nodes,max_normalized,mean_nodes,median_nodes,S_mean)
		row <- row + 1
	
		}
	
	#dev.off()
	analysis_by_radius <- as.data.frame(analysis_by_radius)
	analysis_by_radius
	# Save the analysis data as a csv file
	if(percolation == TRUE)
	{
		file_name <- paste(path_results,"/","analysis_by_radius.csv",sep="")
	} else {
		file_name <- paste(path_results,"/","analysis_by_radius_k",cluster_min,".csv",sep="")
	}
	write.table(analysis_by_radius,file=file_name,col.names=TRUE,sep=",",row.names=FALSE,quote=FALSE)

	# output as png files
	if(percolation == TRUE)
	{
		output_file <- paste(path_results,"/cluster_plots_%02d.png",sep="")
		plot_suffix <- ""
	} else {
		output_file <- paste(path_results,"/cluster_plots_k",cluster_min,"_%02d.png",sep="")
		plot_suffix <- paste("; k=",cluster_min)
	}
	
	png(file=output_file, units="cm", width=21, height=21, res=300)

	#plot(analysis_by_radius$num_clust,analysis_by_radius$max_clust_size,
	#	xlim=NULL, ylim=NULL,
	#	main=paste("max, mean, median size of cluster vs #clusters ", plot_suffix),
	#	sub=paste("Source File: ",source_file_name),
	#	xlab="# clusters, showing radius value", ylab="cluster size")
	#textxy(analysis_by_radius$num_clust,analysis_by_radius$max_clust_size,analysis_by_radius$radius, col="red", cex=.8)
	#points(analysis_by_radius$num_clust,analysis_by_radius$mean_clust_size)
	#textxy(analysis_by_radius$num_clust,analysis_by_radius$mean_clust_size,analysis_by_radius$radius, col="blue", cex=.8)
	#points(analysis_by_radius$num_clust,analysis_by_radius$median_clust_size)
	#textxy(analysis_by_radius$num_clust,analysis_by_radius$median_clust_size,analysis_by_radius$radius, col="green", cex=.8)

	# Plot mean and median on linear scales
	#plot(analysis_by_radius$num_clust,analysis_by_radius$mean_clust_size,
	#	xlim=NULL, ylim=NULL, 
	#	main=paste("mean (blue), median (green) size of cluster vs #clusters ", plot_suffix)),
	#	sub=paste("Source File: ",source_file_name),
	#	xlab="# clusters, showing radius value", ylab="cluster size")
	#textxy(analysis_by_radius$num_clust,analysis_by_radius$mean_clust_size,analysis_by_radius$radius, col="blue", cex=.8)
	#points(analysis_by_radius$num_clust,analysis_by_radius$median_clust_size)
	#textxy(analysis_by_radius$num_clust,analysis_by_radius$median_clust_size,analysis_by_radius$radius, col="green", cex=.8)


	# Plot mean on log log scale
	#plot(analysis_by_radius$num_clust,analysis_by_radius$mean_clust_size,
	#	xlim=NULL, ylim=NULL, log="xy",
	#	main=paste("mean (blue) size of cluster vs #clusters, log-log ", plot_suffix),
	#	sub=paste("Source File: ",source_file_name),
	#	xlab="# clusters, showing radius value", ylab="cluster size")
	#textxy(analysis_by_radius$num_clust,analysis_by_radius$mean_clust_size,analysis_by_radius$radius, col="blue", cex=.8)


	# Plot radius vs S_mean
	plot(analysis_by_radius$radius,analysis_by_radius$S_mean,
		main=paste("S_mean cluster size vs radius ", plot_suffix),
		sub=paste("Source File: ",source_file_name),
		xlab="radius km", ylab="S_mean cluster size")
	lines(analysis_by_radius$radius,analysis_by_radius$S_mean, type="b")
	mtext(paste("excluded: clusters ",upper_threshold," largest & with members <=",lower_threshold))
	textxy(analysis_by_radius$radius,analysis_by_radius$S_mean,analysis_by_radius$radius, col="red", cex=.8)

	# Plot radius vs max_clust_size
	plot(analysis_by_radius$radius,analysis_by_radius$max_clust_size,
		main=paste("Max cluster size vs radius ",plot_suffix),
		sub=paste("Source File: ",source_file_name),
		xlab="radius km", ylab="max cluster size")
	lines(analysis_by_radius$radius,analysis_by_radius$max_clust_size, type="b")
	textxy(analysis_by_radius$radius,analysis_by_radius$max_clust_size,analysis_by_radius$radius, col="red", cex=.8)

	# Plot radius vs normalized max_clust_size
	plot(analysis_by_radius$radius,analysis_by_radius$max_normalized,
		main=paste("Max cluster size (normalized) vs radius ",plot_suffix),
		sub=paste("Source File: ",source_file_name),
		xlab="radius km", ylab="max cluster size (normalized)")
	lines(analysis_by_radius$radius,analysis_by_radius$max_normalized, type="b")
	textxy(analysis_by_radius$radius,analysis_by_radius$max_normalized,analysis_by_radius$radius, col="red", cex=.8)

	dev.off()
}
