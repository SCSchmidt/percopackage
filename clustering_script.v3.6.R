# CLUSTERING SCRIPT, RUNS AFTER NODES LIST SCRIPT
# Original code from Elsa Arcaute, CASA, UCL 28.2.15; extensively modified by Simon Maddison.
# Cite as:	arXiv:1504.08318 [physics.soc-ph]
# Version 3
# This is version 3, incorporating adjustments and enhancements to code 10/5/15 & 2/10/15
# This code computes the clusters, based on matrix of inter-nodal distances computed in script
#  	create_nodes_list_d.vxxx.R
# Note that the list of nodes and internodal distances is not a complete matrix, but only includes
# 	distances below a certain threshold. This keeps the data sizes manageable.
# Note that the original used library bigmemory but this is not available for windows so all refs removed.
# Note that when nodes are individual, they are no longer in a cluster. (31/1/16)
# Version 3.1: 20/04/16 - Note that this intrinsically cannot generate clusters with only one node.
#   	Need to post process means in the analysis script
# Version 3.2: 6/5/16 - Changed Index name to fit within 8 chars -> PlcIndex
# Version 3.3: 18/5/16 - output data into a single file, indexed on PlcIndex and radius instead of separate
#	files. Read in PlcIndex.csv generated by create_nodes_list_d....R
# Version 3.4: 7/11/17 - path of working directory amended for new PC
# Version 3.6: 04/12/18 - changes in Version 3.5 omitted
# 	Add in unit parameter to select km or m, in "radius_values.txt"
#	NOTE: values are assumed to be in metres, unit will factor this in calculations and charts by the unit value
#	so that a unit value of 1 shows through as metres, and a value of 1000 as km. Other values accomodated.
# 	NOTE: no modification necessary to work for fractional values of radius, e.g. step size of 0.1km???????????????

library(igraph)
#setwd("/home/sophie/Dokumente/Konferenzen/percolatransect/") #path on laptop
# paths
path_source <- paste(getwd(),"/source_data",sep="")
path_results <- paste(getwd(),"/working_data",sep="")
data_file <- paste(path_results,"/","nodes_list_d.txt",sep="")

# Read in list of site Indices; file created by create_nodes_list_d.R
file_name <- paste(path_results,"/","PlcIndex.csv",sep="")
# This is used as the basis for the output file
mem_clust_by_r <- read.csv(file_name,header=TRUE, sep = "\t") #seperator is tab

# Read in distance thresholds - this ensures same values used in all scripts
# Edit the  file radius_values.txt to change these.
file_name <- paste(path_results,"/","radius_values.txt",sep="")
radius_values <- read.csv(file_name,header=TRUE)
upper_radius <- radius_values$upper_radius
lower_radius <- radius_values$lower_radius
step_value <- radius_values$step_value
radius_unit <- radius_values$radius_unit

if (radius_unit == 1)
{unit_text <- "m"
} else if (radius_unit == 1000)
{unit_text <- "km"
} else {
unit_text <- paste(radius_unit, "m", sep="")}

print(paste("Radii used for cluster analysis, ",unit_text,": upper ",upper_radius,
	"; lower ",lower_radius,"; step ", step_value))

# To compute and display computational time
ptm <- proc.time()

# The data table of nodes and internode distances is a Text file, with headers
matrix_IDs_distance <- read.table(data_file,header=TRUE)
# Columns are: node Id 1, node Id 2, distance between them. Note that this is generated
#  with a limit to the maximum distance to reduce overall matrix size, and hence
#  creates a partial matrix

t <- as.vector(proc.time() - ptm)[3]
print(paste('time to get matrix in mins',t/60))
ptm2 <- proc.time()[3]

# Define range of percolation radius and step value to progressively reduce it
# Radius in defined unit value, as per radius_unit in radius_values.txt
radius_values <- seq(upper_radius,lower_radius,by=-step_value)

# Changes to accomodate non-integer radius values
radii_count <- length(radius_values)
loop_count <- seq(radii_count,1,by=-1)

# Repeat for each radius value

for (i in loop_count)
{
	print(i)
	radius <- radius_values[i]
	print(radius)
	# Create sub-matrix such that all internode distances d12<=radius
	matrix_radius <- matrix_IDs_distance[matrix_IDs_distance[,3]<=radius,]
	# Create graph (note that characters and numerics are treated differently)
	matrix2 <- matrix_radius[,1:2]
	matrix2[,1] <- as.character(matrix2[,1])
	matrix2[,2] <- as.character(matrix2[,2])
	# This creates a graph from the sub-matrix matrix2
	# Directed means that the edges will only be 'counted' once (tbc)
	# In order to interpret matrix2 as a matrix added 'as.matrix'
	g <- graph.edgelist(as.matrix(matrix2), directed=TRUE)

	#take subcomponents - description of how this works
	#http://stackoverflow.com/questions/20725411/finding-strong-and-weak-clusters-and-their-membership-in-r

	# Identifies clusters in the graph; creates list of nodes and associated cluster id
	# weak refers to the mechanism used to generate the clusters and relates to compuational efficiency
	# Note that this does not include clusters of 1 node, so the counts are not really meaningful at the lower limit
	member_of_cluster_id <- clusters(g, mode="weak")$membership
	# V processes vertices of graph
	m <- cbind(V(g)$name,member_of_cluster_id)
	new_col_name <- paste("ClstRad",radius,sep="")
	colnames(m) <- c("PlcIndex",new_col_name)
	mem_clust_by_r <-  merge(mem_clust_by_r, m, by="PlcIndex", all.x=TRUE)

# following converts NA to zero, but not used
#	mem_clust_by_r[,new_col_name] <- as.numeric(as.character(mem_clust_by_r[,new_col_name]))
#	mem_clust_by_r[is.na(mem_clust_by_r)] <- 0

	ptm1 <- proc.time()[3]
	t_print <-  as.vector(ptm1-ptm2)/60
	print(paste("for radius=",radius,"it took to compute",sprintf("%4.2f",t_print),"mins"))

}

file_name <- paste(path_results,"/","member_cluster_by_radius.csv",sep="")
# Write file without row names
write.csv(mem_clust_by_r,file_name,quote=FALSE,row.names=FALSE)



